* init
#+PROPERTY: header-args :mkdirp t
#+STARTUP: content

** mechanism
Some basic configuration loading mechanisms
#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst hb/configs
    '(introduction os-specific general conclusion transient-states major-modes))

  (defun hb/init ()
    (hb/load-configs hb/configs))

  (defun hb/load-configs (configs)
    (mapc 'hb/load-config configs)  )

  (defun hb/load-config (config)
    (message (format "loading %S..." config))
    (funcall (intern (format "hb/configure-%S" config)))
    (message (format "loading %S... done." config)))
#+END_SRC

** pre-init
These are defaults which must be set before spacemacs initialization.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq exec-path-from-shell-check-startup-files nil)
#+END_SRC
* introduction
** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-introduction ()
    (hb/load-configs '(who-am-i)))
#+END_SRC

** who-am-i
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-who-am-i ()
    (setq user-full-name "Hershal Bhave"))
#+END_SRC

* os-specific
** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-os-specific ()
    (hb/load-configs '()))
#+END_SRC

* general
** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-general ()
    (hb/load-configs '(helm magit mode-line python macros))

    (bind-key "C-x C-b" 'spacemacs/alternate-buffer)
    (setq vc-follow-symlinks t
          evil-move-beyond-eol t
          kill-whole-line t
          shell-command-switch "-ci"
          tramp-auto-save-directory "~/tmp/autosave-tramp/"
          split-height-threshold nil
          split-width-threshold 150
          search-whitespace-regexp "[ \t\r\n\-\*]+"
          tab-always-indent t
          disabled-command-function nil
          auto-insert-query nil)

    (bind-key "C-h C-f" 'find-function)
    (bind-key "C-h C-S-f" 'find-function-at-point)
    (bind-key "C-h C-v" 'find-variable)
    (bind-key "C-h C-S-v" 'find-variable-at-point)
    (bind-key "C-x k" 'kill-this-buffer)
    (bind-key "C-x C-K" 'kill-buffer-and-window)
    (bind-key "M-r" 'replace-string)
    (bind-key "M-R" 'replace-regexp)
    (bind-key "C-c m" 'compile)
    (bind-key "C-c C-m" 'recompile)
    (evil-leader/set-key "bD" 'kill-buffer-and-window)
    (evil-leader/set-key "to" 'overwrite-mode)

    (auto-insert-mode)
    (windmove-default-keybindings)
    (add-hook 'before-save-hook 'whitespace-cleanup))
#+END_SRC
** helm
These are bindings that brings the evil-equivalent helm functionality in
spacemacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-helm ()
    (with-eval-after-load 'helm
      (dolist (keymap (list helm-find-files-map helm-read-file-map helm-map))
        (bind-key "C-h" 'helm-find-files-up-one-level keymap)
        (bind-key "TAB" 'helm-execute-persistent-action keymap)
        (bind-key "C-l" 'helm-execute-persistent-action keymap)))
    (bind-key "C-x C-f" 'spacemacs/helm-find-files)
    (bind-key "C-x b" 'helm-mini)
    (bind-key "C-'" 'helm-M-x)
    (bind-key "M-y" 'helm-show-kill-ring)
    (bind-key "M-y" 'helm-show-kill-ring)
    (setq helm-ff-newfile-prompt-p nil
          helm-buffer-max-length nil
          helm-split-window-default-side 'below
          helm-always-two-windows t))
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-magit ()
    (setq-default git-magit-status-fullscreen t)
    (setq magit-repository-directories "~/repos/"))
#+END_SRC
** mode-line
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mode-line ()
    (setq hb-diminish-modes '(undo-tree-mode
                              holy-mode
                              hybrid-mode
                              smartparens-mode
                              aggressive-indent-mode
                              which-key-mode
                              flyspell-mode
                              flycheck-mode
                              company-mode
                              auto-fill-function))
    (mapc (lambda (mode)
            (eval `(spacemacs|diminish ,mode)))
          hb-diminish-modes)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (spacemacs|diminish evil-org-mode)))
    (add-hook 'yas-minor-mode-hook
              (lambda ()
                (spacemacs|diminish yas-minor-mode))))
#+END_SRC
** python
This is a hack until this pull request goes through:
https://github.com/syl20bnr/spacemacs/pull/5997

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-python ()
    (setq python-shell-interpreter "python3")
    (with-eval-after-load 'python
      (remove-hook 'python-mode-hook 'python-setup-shell)))
#+END_SRC

** macros
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-macros ()
    (hb/load-configs '(split-last-buffer
                       capitalize-line-dwim
                       eval-and-replace
                       comment-line-dwim)))
#+END_SRC
*** split-last-buffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-split-last-buffer ()
    (bind-key "C-x 2" 'vsplit-last-buffer)
    (bind-key "C-x 3" 'hsplit-last-buffer))

  (defun vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))

  (defun hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))
#+END_SRC

*** capitalize-line-dwim
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-capitalize-line-dwim ()
    (bind-key "C-x c" 'capitalize-line-dwim))

  (defun capitalize-line-dwim ()
    (interactive)
    (if (region-active-p)
        (save-excursion
          (let ((beg (region-beginning))
                (end (region-end)))
            (capitalize-region beg end)))
      (save-excursion
        (let ((beg (line-beginning-position))
              (end (line-end-position)))
          (capitalize-region beg end)))))
#+END_SRC

*** eval-and-replace
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-eval-and-replace ()
    (bind-key "C-c C-x C-e" 'eval-and-replace))

  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+END_SRC

*** comment-line-dwim
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-comment-line-dwim ()
    (bind-key "C-;" 'comment-line-dwim))

  (defun comment-line-dwim (&optional arg)
    "Replacement for the comment-dwim command.
      If no region is selected and current line is not blank and we
      are not at the end of the line, then comment current line.
      Replaces default behaviour of comment-dwim, when it inserts
      comment at the end of the line."
    (interactive "*P")
    (comment-normalize-vars)
    (if (or (and (not (region-active-p))
                 (not (looking-at "[ \t]*$")))
            (and (not (equal comment-end ""))
                 (looking-at (hb/quotemeta comment-end))))
        (if (looking-at (hb/quotemeta comment-end))
            (progn
              (comment-or-uncomment-region
               (if (comment-beginning)
                   (comment-beginning)
                 (line-beginning-position))
               (line-end-position))
              (delete-trailing-whitespace
               (line-beginning-position) (line-end-position)))
          (comment-or-uncomment-region
           (line-beginning-position) (line-end-position)))
      (comment-dwim arg)))

  (defun hb/quotemeta (str-val)
    "Return STR-VAL with all non-word characters and / escaped with backslash.
   This is more vigorous than `shell-quote-argument'."
    (save-match-data
      (replace-regexp-in-string "\\([^A-Za-z_0-9 /]\\)" "\\\\\\1" str-val)))


#+END_SRC

*** copy-buffer-file-path
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-copy-buffer-file-path ()
    (evil-leader/set-key "by" 'copy-buffer-file-path))

  (defun copy-buffer-file-path ()
    (interactive)
    (kill-new (buffer-file-name)))
#+END_SRC

* layers
These are layers which tangle into the =layers= directory.

** cmake
:PROPERTIES:
:header-args+: :tangle layers/hb-cmake/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-cmake-packages '(cmake-ide rtags))

  (defun hb-cmake/init-cmake-ide ()
    (use-package cmake-ide))

  (defun hb-cmake/init-rtags ()
    (use-package rtags))

  (defun hb-cmake/post-init-cmake-ide ()
    (setq cmake-ide-build-pool-use-persistent-naming t)
    (cmake-ide-setup))
#+END_SRC
** expand-region
:PROPERTIES:
:header-args+: :tangle layers/hb-expand-region/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-expand-region-packages '(expand-region))

  (defun hb-expand-region/init-expand-region ()
    (use-package expand-region))

  (defun hb-expand-region/post-init-expand-region ()
    (bind-key "C-=" 'er/expand-region)
    (bind-key "C-+" 'er/contract-region))
#+END_SRC
** javascript
:PROPERTIES:
:header-args+: :tangle layers/hb-javascript/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-javascript-packages '(js2-mode typescript-mode))

  (defun hb-javascript/post-init-js2-mode ()
    (setq js-indent-level 2
          js2-basic-offset 2
          js2-include-node-externs t)
    (hb-javascript/configure-skeleton)
    (hb-javascript/configure-node)
    (add-hook 'js2-mode-hook 'hb-javascript/configure-js-style))

  (defun hb-javascript/post-init-typescript-mode ()
    (add-hook 'typescript-mode-hook 'hb-javascript/configure-js-style))

  (defun hb-javascript/configure-skeleton ()
    (define-skeleton js-skeleton "Javascript skeleton" nil "'use strict';" \n \n -)
    (define-auto-insert '("\\.js" . "Javascript skeleton")
      'js-skeleton))

  (defun hb-javascript/configure-js-style ()
    (setq comment-start "/*")
    (setq comment-end "*/"))

  (defun hb-javascript/configure-node ()
    (with-eval-after-load 'js2-mode
      (bind-key "C-x C-n" 'hb-javascript/node-eval js2-mode-map)
      (spacemacs/set-leader-keys-for-major-mode 'js2-mode "n" 'u/node-eval)))

  (defconst node-eval-buffer "*node.js*")

  (defun hb-javascript/node-eval-helper ()
    "Evaluate the current buffer (or region if mark-active), and
  return the result"
    ;; delete the contents of the current node buffer
    (when (get-buffer node-eval-buffer)
      (with-current-buffer node-eval-buffer
        (delete-region (point-min) (point-max))))

    ;; Setup some variables
    (let ((debug-on-error t) (start 1) (end 1))

      ;; If the mark is active, set the point and mark to the selected region;
      ;; else select the entire buffer.
      (cond
       (mark-active
        (setq start (point))
        (setq end (mark)))
       (t
        (setq start (point-min))
        (setq end (point-max))))

      ;; Send the input from `start` to `end` through stdin to the node process.
      ;; This will popluate the `node-eval-buffer` with the results.
      (call-process-region
       start end     ; seems the order does not matter
       "node"        ; node.js
       nil           ; don't delete region
       node-eval-buffer     ; output buffer
       nil)          ; no redisply during output

      (setq deactivate-mark t)
      (with-current-buffer node-eval-buffer
        (buffer-string))))

  (defun hb-javascript/node-eval (&optional prefix)
    "Evalute the current buffer (or region if mark-active), and
  print the result in the message buffer. When given a prefix
  argument, also push the results into the kill-ring."
    (interactive "P")
    (let ((contents (hb-javascript/node-eval-helper)))
      (when prefix (kill-new contents))
      (message "%s" contents)))
#+END_SRC

** lisp
:PROPERTIES:
:header-args+: :tangle layers/hb-lisp/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-lisp-packages '(smartparens aggressive-indent))
#+END_SRC

*** smartparens
#+BEGIN_SRC emacs-lisp
  (defun hb-lisp/post-init-smartparens ()
    (setq sp-ignore-modes-list (delete 'minibuffer-inactive-mode sp-ignore-modes-list))
    (hb-lisp/add-hook-to-lisp-modes 'hb-lisp/configure-lisp-smartparens)
    (smartparens-global-mode))

  (defvar hb-lisp-mode-hooks
    '(emacs-lisp-mode-hook lisp-mode-hook lisp-interaction-mode-hook minibuffer-setup-hook)
    "Major mode hooks which require smartparens to be extra lispy")

  (defun hb-lisp/add-hook-to-lisp-modes (hook-to-add)
    (mapc (lambda (hook)
            (add-hook hook hook-to-add))
          hb-lisp-mode-hooks))

  (defun hb-lisp/configure-lisp-smartparens ()
    (sp-local-pair major-mode "'" nil :actions nil)
    (sp-local-pair major-mode "`" nil :actions nil)
    (turn-on-smartparens-strict-mode))
#+END_SRC

*** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (defun hb-lisp/init-aggressive-indent ()
    (use-package aggressive-indent))

  (defun hb-lisp/post-init-aggressive-indent ()
    (hb-lisp/add-hook-to-lisp-modes 'aggressive-indent-mode))
#+END_SRC

** multiple-cursors
:PROPERTIES:
:header-args+: :tangle layers/hb-multiple-cursors/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-multiple-cursors-packages '(multiple-cursors))

  (defun hb-multiple-cursors/init-multiple-cursors ()
    (use-package multiple-cursors))

  (defun hb-multiple-cursors/post-init-multiple-cursors ()
    (hb/configure-mc))

  (defun hb/configure-mc-isearch ()
    (defvar jc/mc-search--last-term nil)
    (defun jc/mc-search (search-command)
      ;; Read new search term when not repeated command or applying to fake cursors
      (when (and (not mc--executing-command-for-fake-cursor)
                 (not (eq last-command 'jc/mc-search-forward))
                 (not (eq last-command 'jc/mc-search-backward)))
        (setq jc/mc-search--last-term (read-from-minibuffer "Search: ")))
      (funcall search-command jc/mc-search--last-term))
    (defun jc/mc-search-forward ()
      "Simplified version of forward search that supports multiple cursors"
      (interactive)
      (jc/mc-search 'search-forward))
    (defun jc/mc-search-backward ()
      "Simplified version of backward search that supports multiple cursors"
      (interactive)
      (jc/mc-search 'search-backward)))

  (defun hb/configure-mc-bindings ()
    (bind-key "C-S-c C-S-c" 'mc/edit-lines)
    (bind-key "C-S-SPC" 'set-rectangular-region-anchor)
    (bind-key "C->" 'mc/mark-next-like-this)
    (bind-key "C-<" 'mc/mark-previous-like-this)
    (bind-key "C-c C-<" 'mc/mark-all-like-this)
    (bind-key "C-c C->" 'mc/mark-all-like-this-dwim)
    (bind-key "C-c ~" 'mc/insert-numbers)
    (bind-key "M-~" 'mc/sort-regions)
    (bind-key "C-~" 'mc/reverse-regions)
    (bind-key "C-S-c C-e" 'mc/edit-ends-of-lines)
    (bind-key "C-S-c C-a" 'mc/edit-beginnings-of-lines)
    (bind-key "C-s" 'jc/mc-search-forward mc/keymap)
    (bind-key "C-r" 'jc/mc-search-backward mc/keymap))

  (defun hb/configure-mc-fixes ()
    (bind-key "M-SPC" 'just-one-space mc/keymap))

  (defun hb/configure-mc ()
    (hb/configure-mc-isearch)
    (hb/configure-mc-bindings)
    (hb/configure-mc-fixes))
#+END_SRC
** org
:PROPERTIES:
:header-args+: :tangle layers/hb-org/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-org-packages '(org writegood-mode smartparens ox-gfm ob-restclient))
#+END_SRC

*** org
**** general
#+BEGIN_SRC emacs-lisp
  (defun hb-org/post-init-org ()
    (with-eval-after-load 'org
      (hb-org/general-setup)
      (hb-org/template-setup)
      (hb-org/gtd-setup))
    (with-eval-after-load 'ob-tangle
      (remove-hook 'org-babel-pre-tangle-hook 'save-buffer)))

  (defun hb-org/show-subtree-with-context (&optional ignored)
    (save-excursion
      (org-up-element)
      (org-show-subtree)))

  (defun hb-org/tangle-if-modified ()
    (interactive)
    (let ((modified (buffer-modified-p)))
      (save-buffer)
      (if modified (org-babel-tangle))))

  (defun hb-org/tangle-parent-buffer ()
    (interactive)
    (let ((modified (buffer-modified-p)))
      (org-edit-src-save)
      (if modified
          (with-current-buffer (org-src--source-buffer)
            (org-babel-tangle)))))

  (defun hb-org/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at "LOGBOOK" (point))))


  (defun hb-org/template-for-lang (key lang &optional options)
    (list key (concat "#+BEGIN_SRC " lang " "
                      (when (plist-get options :tangle) ":tangle yes")
                      "\n?\n#+END_SRC")))

  (defun hb-org/template-setup ()
    (mapc (lambda (template)
            (add-to-list 'org-structure-template-alist
                         (hb-org/template-for-lang
                          (car template) (cadr template) (cddr template))))
          '(("st" "emacs-lisp" :tangle t)
            ("se" "emacs-lisp")
            ("sh" "sh"))))

  (defun hb-org/general-setup ()
    (bind-key "C-x C-s" 'hb-org/tangle-if-modified org-mode-map)
    (bind-key "C-c j" 'org-goto org-mode-map)
    (bind-key "C-x C-s" 'hb-org/tangle-parent-buffer org-src-mode-map)

    (advice-add 'org-goto :after 'hb-org/show-subtree-with-context)

    (load-library "ob-shell")

    (setq org-special-ctrl-a/e t
          org-goto-interface 'outline-path-completion
          org-goto-max-level 10
          org-outline-path-complete-in-steps nil
          org-src-window-setup 'other-window
          org-startup-indented t
          org-hide-emphasis-markers t
          org-startup-folded 'content
          org-log-into-drawer "LOG"
          org-use-sub-superscripts '{}
          org-export-with-sub-superscripts nil
          org-src-fontify-natively nil
          org-list-allow-alphabetical t
          org-use-fast-todo-selection t
          org-agenda-files '("~/repos/org/")
          org-directory "~/repos/org/"
          org-default-notes-file "~/repos/org/refile.org"
          org-refile-targets '((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))

    (add-hook 'org-clock-out-hook 'remove-empty-drawer-on-clock-out 'append)
    (add-hook 'org-mode-hook 'turn-on-auto-fill))

  (defun hb-org/gtd-setup ()
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n!)" "INPROG(i!)" "WAITING(w!)" "REVIEW(r!)" "|" "DONE(d!)")
            (sequence "PLAN(!p)" "|" "MEETING(m!)")
            (sequence "TODO(t)" "HOLD(h!)" "INPROG(i!)" "WAITING(w!)" "NEXT(n!)" "REVIEW(r!)" "|" "DONE(d!)")))
    (setq org-todo-keyword-faces
          '(("TODO" :foreground "red" :weight bold)
            ("REVIEW" :foreground "orange" :weight bold)
            ("NEXT" :foreground "orange" :weight bold)
            ("INPROG" :foreground "orange" :weight bold)
            ("HOLD" :foreground "orange" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("DONE" org-done)
            ("CANCELLED" org-done)
            ("PLAN" :foreground "purple" :weight bold)
            ("MEETING" :foreground "blue" :weight bold))))
#+END_SRC
**** capture
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "todo" entry (file "~/repos/org/refile.org")
           "* TODO %?\n%U\n%a\n")
          ("j" "Journal" entry (file+datetree "~/repos/org/diary.org")
           "* %?\n%U\n")
          ("m" "Meeting" entry (file "~/repos/org/refile.org")
           "* MEETING with %? :meeting:\n%U")))
#+END_SRC
*** ox-gfm
#+BEGIN_SRC emacs-lisp
  (defun hb-org/init-ox-gfm ()
    (use-package ox-gfm))
#+END_SRC
*** ob-restclient
#+BEGIN_SRC emacs-lisp
  (defun hb-org/init-ob-restclient ()
    (use-package ob-restclient))
#+END_SRC

*** writegood
#+BEGIN_SRC emacs-lisp
  (defun hb-org/init-writegood-mode ()
    (use-package writegood-mode))

  (defun hb-org/post-init-writegood-mode ()
    (add-hook 'org-mode-hook 'writegood-turn-on))
#+END_SRC

*** smartparens
#+BEGIN_SRC emacs-lisp
  (defun hb-org/post-init-smartparens ()
    (add-hook 'org-mode-hook 'hb-org/configure-smartparens))

  (defun hb-org/configure-smartparens ()
    (sp-local-pair 'org-mode "/" "/" :unless '(sp-point-after-word-p))
    (sp-local-pair 'org-mode "_" "_" :unless '(sp-point-after-word-p))
    (sp-local-pair 'org-mode "=" "=" :unless '(sp-point-after-word-p))
    (sp-local-pair 'org-mode "'" "'" :unless '(sp-point-after-word-p))
    (sp-local-pair 'org-mode "`" "`" :unless '(sp-point-after-word-p)))
#+END_SRC

** smartparens
:PROPERTIES:
:header-args+: :tangle layers/hb-smartparens/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-smartparens-packages '(smartparens))

  (defun hb-smartparens/init-smartparens ()
    (message "initializing smartparens")
    (use-package smartparens))

  (defun hb-smartparens/post-init-smartparens ()
    (hb-smartparens/configure))

  (defun hb-smartparens/configure ()
    (smartparens-global-mode)
    (show-smartparens-global-mode)
    (hb-smartparens/configure-bindings)
    (hb-smartparens/configure-specialcase))

  (defun hb-smartparens/configure-bindings ()
    (dolist (binding hb/smartparens-bindings)
      (bind-key (car binding) (cdr binding) smartparens-mode-map)))

  (defvar hb/smartparens-bindings
    '(("C-*" . sp-wrap-with-parens)
      ("C-\"" . sp-wrap-with-double-quotes)
      ("C-<backspace>" . sp-splice-sexp)
      ("C-)" . sp-forward-slurp-sexp)
      ("C-(" . sp-forward-barf-sexp)
      ("C-{" . sp-backward-slurp-sexp)
      ("C-}" . sp-backward-barf-sexp)
      ("M-<up>" . sp-splice-sexp-killing-backward)))

  (defun sp-wrap-with-double-quotes (&optional arg)
    (interactive "P")
    (sp-wrap-with-pair "\""))

  (defun sp-wrap-with-parens (&optional arg)
    (interactive "P")
    (sp-wrap-with-pair "("))

  (defun hb-smartparens/configure-specialcase ()
    (sp-local-pair 'text-mode "'" "'" :unless '(sp-point-after-word-p)))
#+END_SRC

** TODO spell-checking
I need to turn on spell checking for the major modes I would like to
spell-check.

** TODO visual-fill-colum-mode

** web
:PROPERTIES:
:header-args+: :tangle layers/hb-web/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-web-packages '(web-mode))

  (defun hb-web/post-init-web-mode ()
    (add-hook 'web-mode-hook 'hb-web/configure-web-mode))

  (defun hb-web/configure-web-mode ()
    (mapc (lambda (mode)
            (set (intern-soft (format "web-mode-%S-indent-offset" mode)) 2))
          '(css sql code attr-value attr markup))
    (setq web-mode-enable-current-column-highlight t)
    (setq web-mode-enable-current-element-highlight t))
#+END_SRC

** yasnippet
:PROPERTIES:
:header-args+: :tangle layers/hb-yasnippet/packages.el
:END:

#+BEGIN_SRC emacs-lisp
  (setq hb-yasnippet-packages '(yasnippet))

  (defun hb-yasnippet/post-init-yasnippet ()
    (add-hook 'prog-mode-hook 'yas-minor-mode-on)
    (bind-key "TAB" 'yas-expand yas-minor-mode-map))
#+END_SRC

* transient-states
** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-transient-states ()
    (hb/load-configs '(movement-transient-state)))
#+END_SRC
** movement
Scrolling in emacs corresponds to moving the document, not the viewport. Thus
"scrolling up" moves the document down, or appears as if the viewport moves up.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar hb/scrolling-distance 10)

  (defun hb/configure-movement-transient-state ()
    (spacemacs|define-transient-state movement
      :doc "[j]down [k]up [f]orward [b]ack [u]p [d]own [q]uit"
      :evil-leader "m."
      :bindings
      ("j" hb/scroll-up)
      ("k" hb/scroll-down)
      ("f" scroll-up-command)
      ("b" scroll-down-command)
      ("d" hb/scroll-up-half-page)
      ("u" hb/scroll-down-half-page)
      ("q" nil :exit t)))

  (defun hb/scroll-down ()
    (interactive)
    (scroll-down-command hb/scrolling-distance))

  (defun hb/scroll-up ()
    (interactive)
    (scroll-up-command hb/scrolling-distance))

  (defun hb/scroll-down-half-page ()
    (interactive)
    (scroll-down-command (/ (window-height) 2)))

  (defun hb/scroll-up-half-page ()
    (interactive)
    (scroll-up-command (/ (window-height) 2)))

#+END_SRC
* major-modes
** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-major-modes ()
    (hb/load-configs '(clang-major-mode compilation-major-mode help-major-mode)))
#+END_SRC

** clang
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-clang-major-mode ()
    (add-hook 'c++-mode-hook 'hb/configure-clang-major-mode-hook))

  (defun hb/configure-clang-major-mode-hook ()
    (setq c-basic-offset 4
          comment-start "/*"
          comment-end "*/"
          company-clang-arguments "-std=c++14"
          flycheck-clang-args "-std=c++14"))
#+END_SRC

** compilation-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-compilation-major-mode ()
    (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
    (add-hook 'compilation-finish-functions 'compilation-remove-window-on-success))

  (defun colorize-compilation-buffer ()
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region compilation-filter-start (point-max))))

  (defun compilation-remove-window-on-success (buffer exit-str)
    (when (string-match "finished" exit-str)
      (message (format "burying buffer: %s" exit-str))
      (with-current-buffer buffer
        (bury-buffer buffer)
        (delete-windows-on buffer))))
#+END_SRC

** help-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-help-major-mode ()
    (bind-key "[" 'help-go-back help-mode-map)
    (bind-key "]" 'help-go-forward help-mode-map))
#+END_SRC
* conclusion

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-conclusion ()
    (find-file hb/init-file))
  (provide 'init-new)
#+END_SRC

All done!
